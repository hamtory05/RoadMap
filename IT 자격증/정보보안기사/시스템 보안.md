<h2 align = "center"> 시스템 보안 </h2>

## CPU 정의
#### CPU : 입력장치로부터 자료를 받아 연산 후 결과를 출력하는 장치, 제어장치와 기억장치가 있다.

<br>

## CPU 구성요소
#### 1. ALU (연산장치)
* 산술연산, 논리연산, 데이터비교를 담당.
* CPU의 계산 중심 역할.
* 실행 결과값을 레지스터에 저장.

#### 2. 레지스터 
* CPU가 즉시 사용할 데이터를 보관
* 명령어 실행 중간 결과를 기억
* 용량은 작지만 속도는 매우 빠름

#### 3. Control Unit (제어장치)
* CPU의 지휘자 역할
* 명령어를 해석하고 제어신호를 생성
* ALU, 레지스터, 메모리 간의 작업 흐름 관리
* 명령어 사이클을 기반으로 동작

#### 4. 내부 CPU 버스
* CPU 내부 구성 요소(ALU, 레지스터 메모리 등) 간 데이터 전달 통로
* CPU 내부에서 명령어 및 데이터를 이동시키는게 사용

<br>

## 레지스터 종류
#### 1. PC (Program Counter)
* 다음에 수행할 주기억장치(메모리 등) 주소 저장
* 프로그램 실행의 흐름을 제어

#### 2. MAR (Memory Address Register)
* 주기억장치(메모리)에 접근하기 위해 필요한 주기억장치(메모리) 주소 기억
* CPU와 메모리 간 데이터를 주고받는 데 중요한 역할

#### 3. MBR (Memory Buffer Register)
* 주기억장치에서 읽어온 데이터 또는 CPU에서 쓰려고 하는 데이터를 임시 저장
* 메모리와 CPU 간의 데이터 버퍼 역할을 수행
* 읽기 작업 : 주기억장치(메모리)에서 데이터를 가져와 MBR에 저장
* 쓰기 작업 : 데이터를 MBR에 저장한 후 주기억장치(메모리)에 전달

#### IR (Insturction Register)
* 주기억장치에서 인출한 명령어를 저장
* 연산코드와 피연산자 등을 포함
* CPU가 어떤 작업을 수행해야 할지 명확히 알 수 있도록 함

<br>

## 버스 종류 (입출력 영향을 끼침)
#### 1. 데이터 버스
* 데이터가 전송되는 경로
* CPU, 기억장치, I/O 장치 등에서 데이터를 주고 받을 때 사용
* I/O 장치 : 입출력 장치로 입력과 출력을 동시에 처리할 수 있음
  
#### 2. 주소 버스
* 기억장치의 위치나 I/O 장치의 식별을 위한 주소 전송

#### 3. 제어 버스
* CPU, 기억장치, I/O 장치 사이의 제어 신호를 전송

<br>

## CPU 명령 실행 주기
#### 1. 인출 (Instruction Fetch)
* 메모리 데이터를 로드하여 레지스터에 저장

#### 2. 간접 (Indrection)
* 간접 주소 방식 채택 경우 -> CPU가 메모리 주소를 찾고 데이터를 불러옴

#### 3. 실행 (Execution)
* 명령, 데이터, 산술 연산, 논리 연산 수행

#### 4. 인터럽트 (Interrupt)
* 예기치않은 문제 발생시 업무처리 가능하게 하는 기능

<br>

## 기억장치 계층구조

* 레지스터 : CPU 내부에서 연산을 빠르게 처리하기 위해 사용
* 캐시 : CPU와 메모리 사이에 위치한 고속 메모리
* 주기억장치 : RAM, 데이터와 명령어를 저장하는 메모리
* 보조기억장치 : HDD, SSD, USB

| **기억장치**       | **용량**           | **비용**         | **속도**      |
|-----------------|------------------|----------------|-------------|
| **레지스터**      | 매우 작음        | 매우 큼         | 매우 빠름    |
| **캐시**          | 작음             | 큼              | 빠름         |
| **주기억장치**    | 큼               | 작음            | 느림         |
| **보조기억장치**  | 매우 큼          | 매우 작음       | 매우 느림    |

<br>

## 캐시메모리 및 캐시 슬롯 정의
#### 캐시메모리 : CPU와 주기억장치 속도차이 극복을 위한 버퍼 메모리(기억장치)
#### 캐시 슬롯 : 캐시 메모리 내에서 데이터를 저장하는 개별적인 위치 또는 공간을 의미

## 캐시 메모리 사상 방식
#### 1. 직접 사상 (Direct Mapping)
| **사상 방식**                | **특징**                                                 | **장점**                             | **단점**                                |
|-------------------------|-----------------------------------------------------|----------------------------------|-------------------------------------|
| **직접사상 (Direct Mapping)**  | 메인 메모리를 여러구역으로 분할하여 캐시 슬롯과 직접 매핑              | 구현이 간단하고 빠름.                   | 충돌 가능성, 캐시 활용도가 낮음.           |

#### 2. 집합 연관 사상 (Set-Associate Mapping)
| **사상 방식**                | **특징**                                                 | **장점**                             | **단점**                                |
|-------------------------|-----------------------------------------------------|----------------------------------|-------------------------------------|
| **집합 연관사상 (Set-Associative Mapping)** | 직접사상 + 연관 방법 메로리를 블록으로 분할하여 매핑          | 캐시 활용도가 높고 충돌이 적음.            | 구현 복잡성 증가, 추가 하드웨어 필요.       |

#### 3. 연관 사상 (Associate Mapping)
| **사상 방식**                | **특징**                                                 | **장점**                             | **단점**                                |
|-------------------------|-----------------------------------------------------|----------------------------------|-------------------------------------|
| **연관 사상 (Associative Mapping)**   | 메인 메모리 블록들이 캐시 슬롯 어느곳이든 매핑(적재) 가능               | 충돌이 거의 없고, 캐시 효율적 사용.         | 매우 복잡한 구현, 검색 시간이 더 걸림.     |

<br>

## 캐시메모리 관리 방식
#### CPU가 빠르게 데이터에 접근할 수 있도록 효율적으로 데이터를 저장하고 교체하는 과정

#### 1. 호출기법
* 요구 호출 (Demand Fetch) : 데이터 필요시, 데이터를 캐시메모리에서 인출
* 선행 호출 (Pre-Fetch) : 필요한 데이터를 예측하여 캐시 메모리에 로듵`

#### 2. 교체기법 (메모리 교체 알고리즘)
* FIFO (First In First Out) : 가장 오래 있었던 Page 교체 / 자주 사용되던 페이지가 교체될 수 있음
* LFU (Least Frequently Used) : 가장 횟수가 적은 Page 교체 / 가장 새로 들어온 페이지가 교체될 수 있음
* LRU (Least Recently Used) : 가장 오랫동안 사용되지 않은 Page 교체 / 오버헤드 우려
* NUR (Not Used Recently) : 미사용 Page 교체
* SCR (Second Chance Replacement) : 최초 참조 비트 1, 1 -> 0 두번 기회

#### 페이지 교체시 문제점
| **문제**            | **설명**                                                                                       | **문제 발생 원인**                                                             |
|-------------------|--------------------------------------------------------------------------------------------|----------------------------------------------------------------------------|
| **Page Fault** | 프로세스가 실행 중에 필요한 페이지가 메모리에 없을 때 발생하는 오류. 디스크에서 페이지를 로드해야 함.      | 필요한 페이지가 메모리에 없을 때 발생. 디스크 I/O가 자주 발생하면 성능 저하.                |
| **Demand Paging** | 필요한 페이지만 메모리에 로드하는 방식. 페이지 폴트가 발생하면 해당 페이지를 디스크에서 로드.                | 페이지 폴트가 자주 발생하면 성능이 저하되고, 디스크 I/O가 증가.                        |
| **Thrashing**       | 페이지 폴트가 지나치게 자주 발생하여, 프로세스가 실제로 실행되기보다는 페이지 교체에 많은 시간을 소비하는 상태. | 프로세스가 메모리 요구를 초과할 때, 또는 시스템에서 여러 프로세스가 과도하게 메모리를 요구할 때. |

<br>

## 가상 메모리 정의
#### 가상 메모리 : Virtual Address Space 사용, 물리적 메모리보다 더 큰 용량 사용

## 가상 메모리 단위  (비연속 할당)
#### 1. 페이지 (Page) 
* 동일한 크기의 논리 분할 단위 (Ex. 4KB, 8KB)
* 내부 단편화 : 페이지의 크기는 고정, 할당된 공간보다 크게 차지되면 낭비되는 공간이 발생
  
#### 2. 세그먼트 (Segment)
* 용도별로 논리적 단위를 나눔
* 외부 단편화 : 세그먼트의 크기는 가변적, 사이에 빈 공간이 발생할 수 있음

#### 3. 연속할당 (Contiguous Allocation)
* 고정 분할 : 메모리를 고정된 크기로 나누고, 각 영역에 프로세스를 할당 (단점 : 내부 단편화)
* 가변 분할 : 메모리를 가변 크기로 나누고, 프로세스가 요구하는 크기만큼 공간 할당 (단점 : 외부 단편화)

<br>

## I/O 인터페이스
#### CPU경유와 CPU 비경유 방식으로 나뉜다

### CPU 경유
#### 1. 프로그램에 의한 I/O (Poling 방식)
* CPU가 직접 주변 장치를 연속적으로 감시하여 데이터를 처리하는 방식
* 구현이 간단하고 작은 시스템에서 유용
* CPU가 계속 감시 작업을 해야하므로 비효율적이고 자원이 낭비될 수 있음

#### 2. 인터럽트에 의한 I/O
* CPU가 신호를 보내 작업을 중지하고 데이터를 처리하는 방식
* CPU가 계속 주변 장치를 감시할 필요가 없어지므로 효율적
* 인터럽트가 자주 발생하면 CPU가 자주 컨텍스트 전환을 하게 되어, 성능 저하가 발생


### CPU 비경유
#### 1. DMA (Direct Memory Access)
* CPU 개입 X, 메모리와 주변장치를 직접 관리
* 전송 속도가 빠르고 시스템 성능이 향상
* Cycle Stealing : CPU 사용하지 않는 버스를 점유
* Burst Mode : 버스를 장기간 점유

#### 채널 I/O (I/O Processor)
* Multplexer Channel : 저속 장치에 사용, 시분할 방식을 사용
* Selector Channel : 고속 장치에 사용, 단일 입출력 작업에 집중

<br>

## 운영체제 정의 
#### 컴퓨터 시스템의 자원들을 효율적으로 관리, 사용자의 컴퓨터 사용 편의성 환경 제공

<br>

## 운영체제의 목적
#### 1. 처리능력 향샹
#### 2. 신뢰성 향상
#### 3. 응답시간의 단축
#### 4. 자원 활용률 향상
#### 5. 가용성 향상

<br>

## 운영체제 주요 자원 관리 기능
#### 1. 프로세스 관리
#### 2. 기억장치 관리
#### 3. 주변 장치 관리
#### 4. 파일 관리

<br>

## 프로세스 관리 (Process Management)

#### 1. 프로세스 
* 레지스터, 스택, 포인터, 실행중인 프로그램, 데이터 등의 집합체
* 실행중인 프로그램, PCB보유, Library Call, 자원할당의 기본 단위

#### 2. 스레드 
* 프로세스 내에서 실행되는 제어 흐름
* CPU 작업의 기본 단위
* 프로세스에서 실행되는 작업은 세분화하여 병행 실행할 수 있게 해줌
* 시스템 호출 (System Call) : 프로세스가 커널의 서비스를 요청, 스레드도 시스템 호출을 통해 자원 요청 가능

<br>

## CPU 스케줄링 기법
#### - 프로세스 상태 전이
#### - 자원을 효율적으로 사용하기 위한 정책, 자원을 요청하는 프로세스 순서를 정함

<br>

### 점유 방식 
#### 1. 선점 (Preemptive) : 프로세스 CPU 점유 시 다른 프로세스 점유 가능 (Round-robin, SRT)
#### 2. 비선점 (Non-preemtive) : 프로세스 CPU 점유식 독점 (FCFS, SJF, HRN)

<br>

### 선점 방식
#### 1. Round-robin (RR) 
* 각 프로세스는 같은 시간동안 CPU를 할당 받음
* 시간이 다 되면 대기 큐로 돌아가고 다음 프로세스에게 CPU 할당

#### 2. SRT (Shortest Remaining Time)
* 수행 시간이 짧은 작업부터 실행하되, 실행 중 다른 프로세스가 더 짧은 시간일 경우 CPU를 점유할 수 있음

### 비선점 방식
#### 1. FCFS (First Come First Service)
* 대기 큐에 도착한 순서대로 CPU를 할당

#### 2. SJF (Short Job First)
* 수행 시간이 짧은 작업부터 CPU 할당
  
#### 3. HRN (Highest Ratio Next)
*SJF를 개선하여, 우선순위가 높은 프로세스에게 CPU 할당

<br>

### Multi Level Queue
* 비선점 방식, 선점 방식 둘 다 가능
* 여러종류의 그룹(큐)로 나누어 각자 독자적인 스케줄링 기법 사용
  
### Mulit Level Feedback Queue
* 그룹(큐)들을 라운드 로빈이나 비선점 방식을 통해 스케줄링 (Hybrid 스케줄링)

<br>

## 병행성 제어
### 상호 배제 (Mutual Exclusion Techniques)
* 다수의 프로세스 동일 자원 접근 시 무결성 보장, 임계영역 사용

#### 1. 임계 영역 (Critical Section)
* 공유 자원의 독점을 보장하는 코드 영역
* 병렬 컴퓨팅 및 동기화 문제 해결에 사용
* 세마포어 개념 이용
* 세마포어 : 공유 자원의 개수를 나타내는 변수, 프로세스 간 동기화를 위해 사용

#### 2. 모니터 상호배제 기법
* 하나의 프로세스만이 모니터 내부에 존재해야함
* 모니터 내부의 지역변수로 정의
* 모니터의 지역변수는 외부에서 접근할 수 없음.

<br>

### 교착 상태 (Dead Lock)
* 하나 이상의 프로세스가 더 이상 계속할 수 없는 특정 사건을 기다리고 있는 상태

<br>

### 교착 상태 발생 조건
#### 1. 상호배제 
* 하나 이상의 프로세스가 자원을 배타 점유
#### 2. 점유와 대기
* 부분할당으로 다른 종류의 자원을 요구하면서 자원 점유
#### 3. 비선점 
* 자원이 해제 되지 않음
#### 4. 환형대기
* 프로세스와 자원들이 원형을 이루며 서로 상대방의 자원을 요청

<br>

### 교착 상태 대응 방법

#### 1. 예방 (Prevention) : 필요 조건을 부정, 교착상태 예방 
* 점유와 대기 부정 : 필요한 자원을 일시에 요청
* 비선점 조건의 부정 : 자원점유 후 자원 요청시 자원해제 선 요청
* 환형대기 조건 부정 : 프로세스들의 자원별로 우선순의 결정
* 상호배제 조건 부정 : 자원 비공유 전제

#### 2. 회피 (Avoidence) : 가능성을 인정, 회피
* 은행원 알고리즘 (안정상태, 불안정상태) : 프로세스가 요구한 최대 요구량 만큼 자원을 할당 (안전순서서열 존재, 교착 상태는 불안전상태에서만 일어남)

#### 3. 발견 (Detection) : 교착상태 발생 허용, 원인을 규명하고 해결
* 교착상태 발견 알고리즘 : 교착상태 발생 검사 알고리즘, 교착상태 빈도수 파악
* 자원할당 그래프 : 방향그래프를 이용, 그래프 소거법을 이용하여 교착상태 감지

#### 4. 회복 (Recovery)
* 프로세스 중지 : 교착 상태를 유발한 프로세스를 종료
* 선점 : 자원을 강제로 회수하여 재분배배




























































































































