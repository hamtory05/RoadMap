<h2 align = "center"> 시스템 보안 </h2>

## CPU 정의
#### CPU : 입력장치로부터 자료를 받아 연산 후 결과를 출력하는 장치, 제어장치와 기억장치가 있다.

<br>

## CPU 구성요소
#### 1. ALU (연산장치)
* 산술연산, 논리연산, 데이터비교를 담당.
* CPU의 계산 중심 역할.
* 실행 결과값을 레지스터에 저장.

#### 2. 레지스터 
* CPU가 즉시 사용할 데이터를 보관
* 명령어 실행 중간 결과를 기억
* 용량은 작지만 속도는 매우 빠름

#### 3. Control Unit (제어장치)
* CPU의 지휘자 역할
* 명령어를 해석하고 제어신호를 생성
* ALU, 레지스터, 메모리 간의 작업 흐름 관리
* 명령어 사이클을 기반으로 동작

#### 4. 내부 CPU 버스
* CPU 내부 구성 요소(ALU, 레지스터 메모리 등) 간 데이터 전달 통로
* CPU 내부에서 명령어 및 데이터를 이동시키는게 사용

<br>

## 레지스터 종류
#### 1. PC (Program Counter)
* 다음에 수행할 주기억장치(메모리 등) 주소 저장
* 프로그램 실행의 흐름을 제어

#### 2. MAR (Memory Address Register)
* 주기억장치(메모리)에 접근하기 위해 필요한 주기억장치(메모리) 주소 기억
* CPU와 메모리 간 데이터를 주고받는 데 중요한 역할

#### 3. MBR (Memory Buffer Register)
* 주기억장치에서 읽어온 데이터 또는 CPU에서 쓰려고 하는 데이터를 임시 저장
* 메모리와 CPU 간의 데이터 버퍼 역할을 수행
* 읽기 작업 : 주기억장치(메모리)에서 데이터를 가져와 MBR에 저장
* 쓰기 작업 : 데이터를 MBR에 저장한 후 주기억장치(메모리)에 전달

#### IR (Insturction Register)
* 주기억장치에서 인출한 명령어를 저장
* 연산코드와 피연산자 등을 포함
* CPU가 어떤 작업을 수행해야 할지 명확히 알 수 있도록 함

<br>

## 버스 종류 (입출력 영향을 끼침)
#### 1. 데이터 버스
* 데이터가 전송되는 경로
* CPU, 기억장치, I/O 장치 등에서 데이터를 주고 받을 때 사용
* I/O 장치 : 입출력 장치로 입력과 출력을 동시에 처리할 수 있음
  
#### 2. 주소 버스
* 기억장치의 위치나 I/O 장치의 식별을 위한 주소 전송

#### 3. 제어 버스
* CPU, 기억장치, I/O 장치 사이의 제어 신호를 전송

<br>

## CPU 명령 실행 주기
#### 1. 인출 (Instruction Fetch)
* 메모리 데이터를 로드하여 레지스터에 저장

#### 2. 간접 (Indrection)
* 간접 주소 방식 채택 경우 -> CPU가 메모리 주소를 찾고 데이터를 불러옴

#### 3. 실행 (Execution)
* 명령, 데이터, 산술 연산, 논리 연산 수행

#### 4. 인터럽트 (Interrupt)
* 예기치않은 문제 발생시 업무처리 가능하게 하는 기능

<br>

## 기억장치 계층구조

* 레지스터 : CPU 내부에서 연산을 빠르게 처리하기 위해 사용
* 캐시 : CPU와 메모리 사이에 위치한 고속 메모리
* 주기억장치 : RAM, 데이터와 명령어를 저장하는 메모리
* 보조기억장치 : HDD, SSD, USB

| **기억장치**       | **용량**           | **비용**         | **속도**      |
|-----------------|------------------|----------------|-------------|
| **레지스터**      | 매우 작음        | 매우 큼         | 매우 빠름    |
| **캐시**          | 작음             | 큼              | 빠름         |
| **주기억장치**    | 큼               | 작음            | 느림         |
| **보조기억장치**  | 매우 큼          | 매우 작음       | 매우 느림    |

<br>

## 캐시메모리 및 캐시 슬롯 정의
#### 캐시메모리 : CPU와 주기억장치 속도차이 극복을 위한 버퍼 메모리(기억장치)
#### 캐시 슬롯 : 캐시 메모리 내에서 데이터를 저장하는 개별적인 위치 또는 공간을 의미

## 캐시 메모리 사상 방식
#### 1. 직접 사상 (Direct Mapping)
| **사상 방식**                | **특징**                                                 | **장점**                             | **단점**                                |
|-------------------------|-----------------------------------------------------|----------------------------------|-------------------------------------|
| **직접사상 (Direct Mapping)**  | 메인 메모리를 여러구역으로 분할하여 캐시 슬롯과 직접 매핑              | 구현이 간단하고 빠름.                   | 충돌 가능성, 캐시 활용도가 낮음.           |

#### 2. 집합 연관 사상 (Set-Associate Mapping)
| **사상 방식**                | **특징**                                                 | **장점**                             | **단점**                                |
|-------------------------|-----------------------------------------------------|----------------------------------|-------------------------------------|
| **집합 연관사상 (Set-Associative Mapping)** | 직접사상 + 연관 방법 메로리를 블록으로 분할하여 매핑          | 캐시 활용도가 높고 충돌이 적음.            | 구현 복잡성 증가, 추가 하드웨어 필요.       |

#### 3. 연관 사상 (Associate Mapping)
| **사상 방식**                | **특징**                                                 | **장점**                             | **단점**                                |
|-------------------------|-----------------------------------------------------|----------------------------------|-------------------------------------|
| **연관 사상 (Associative Mapping)**   | 메인 메모리 블록들이 캐시 슬롯 어느곳이든 매핑(적재) 가능               | 충돌이 거의 없고, 캐시 효율적 사용.         | 매우 복잡한 구현, 검색 시간이 더 걸림.     |

<br>

## 캐시메모리 관리 방식
#### CPU가 빠르게 데이터에 접근할 수 있도록 효율적으로 데이터를 저장하고 교체하는 과정

#### 1. 호출기법
* 요구 호출 (Demand Fetch) : 데이터 필요시, 데이터를 캐시메모리에서 인출
* 선행 호출 (Pre-Fetch) : 필요한 데이터를 예측하여 캐시 메모리에 로듵`

#### 2. 교체기법 (메모리 교체 알고리즘)
* FIFO (First In First Out) : 가장 오래 있었던 Page 교체 / 자주 사용되던 페이지가 교체될 수 있음
* LFU (Least Frequently Used) : 가장 횟수가 적은 Page 교체 / 가장 새로 들어온 페이지가 교체될 수 있음
* LRU (Least Recently Used) : 가장 오랫동안 사용되지 않은 Page 교체 / 오버헤드 우려
* NUR (Not Used Recently) : 미사용 Page 교체
* SCR (Second Chance Replacement) : 최초 참조 비트 1, 1 -> 0 두번 기회

#### 페이지 교체시 문제점
| **문제**            | **설명**                                                                                       | **문제 발생 원인**                                                             |
|-------------------|--------------------------------------------------------------------------------------------|----------------------------------------------------------------------------|
| **Page Fault** | 프로세스가 실행 중에 필요한 페이지가 메모리에 없을 때 발생하는 오류. 디스크에서 페이지를 로드해야 함.      | 필요한 페이지가 메모리에 없을 때 발생. 디스크 I/O가 자주 발생하면 성능 저하.                |
| **Demand Paging** | 필요한 페이지만 메모리에 로드하는 방식. 페이지 폴트가 발생하면 해당 페이지를 디스크에서 로드.                | 페이지 폴트가 자주 발생하면 성능이 저하되고, 디스크 I/O가 증가.                        |
| **Thrashing**       | 페이지 폴트가 지나치게 자주 발생하여, 프로세스가 실제로 실행되기보다는 페이지 교체에 많은 시간을 소비하는 상태. | 프로세스가 메모리 요구를 초과할 때, 또는 시스템에서 여러 프로세스가 과도하게 메모리를 요구할 때. |

<br>

## 가상 메모리 정의
#### 가상 메모리 : Virtual Address Space 사용, 물리적 메모리보다 더 큰 용량 사용

## 가상 메모리 단위  (비연속 할당)
#### 1. 페이지 (Page) 
* 동일한 크기의 논리 분할 단위 (Ex. 4KB, 8KB)
* 내부 단편화 : 페이지의 크기는 고정, 할당된 공간보다 크게 차지되면 낭비되는 공간이 발생
  
#### 2. 세그먼트 (Segment)
* 용도별로 논리적 단위를 나눔
* 외부 단편화 : 세그먼트의 크기는 가변적, 사이에 빈 공간이 발생할 수 있음

#### 3. 연속할당 (Contiguous Allocation)
* 고정 분할 : 메모리를 고정된 크기로 나누고, 각 영역에 프로세스를 할당 (단점 : 내부 단편화)
* 가변 분할 : 메모리를 가변 크기로 나누고, 프로세스가 요구하는 크기만큼 공간 할당 (단점 : 외부 단편화)

<br>

## I/O 인터페이스
#### CPU경유와 CPU 비경유 방식으로 나뉜다

### CPU 경유
#### 1. 프로그램에 의한 I/O (Poling 방식)
* CPU가 직접 주변 장치를 연속적으로 감시하여 데이터를 처리하는 방식
* 구현이 간단하고 작은 시스템에서 유용
* CPU가 계속 감시 작업을 해야하므로 비효율적이고 자원이 낭비될 수 있음

#### 2. 인터럽트에 의한 I/O
* CPU가 신호를 보내 작업을 중지하고 데이터를 처리하는 방식
* CPU가 계속 주변 장치를 감시할 필요가 없어지므로 효율적
* 인터럽트가 자주 발생하면 CPU가 자주 컨텍스트 전환을 하게 되어, 성능 저하가 발생


### CPU 비경유
#### 1. DMA (Direct Memory Access)
* CPU 개입 X, 메모리와 주변장치를 직접 관리
* 전송 속도가 빠르고 시스템 성능이 향상
* Cycle Stealing : CPU 사용하지 않는 버스를 점유
* Burst Mode : 버스를 장기간 점유

#### 채널 I/O (I/O Processor)
* Multplexer Channel : 저속 장치에 사용, 시분할 방식을 사용
* Selector Channel : 고속 장치에 사용, 단일 입출력 작업에 집중

<br>

## 운영체제 정의 
#### 컴퓨터 시스템의 자원들을 효율적으로 관리, 사용자의 컴퓨터 사용 편의성 환경 제공

<br>

## 운영체제의 목적
#### 1. 처리능력 향샹
#### 2. 신뢰성 향상
#### 3. 응답시간의 단축
#### 4. 자원 활용률 향상
#### 5. 가용성 향상

<br>

## 운영체제 주요 자원 관리 기능
#### 1. 프로세스 관리
#### 2. 기억장치 관리
#### 3. 주변 장치 관리
#### 4. 파일 관리

<br>

## 프로세스 관리 (Process Management)

#### 1. 프로세스 
* 레지스터, 스택, 포인터, 실행중인 프로그램, 데이터 등의 집합체
* 실행중인 프로그램, PCB보유, Library Call, 자원할당의 기본 단위

#### 2. 스레드 
* 프로세스 내에서 실행되는 제어 흐름
* CPU 작업의 기본 단위
* 프로세스에서 실행되는 작업은 세분화하여 병행 실행할 수 있게 해줌
* 시스템 호출 (System Call) : 프로세스가 커널의 서비스를 요청, 스레드도 시스템 호출을 통해 자원 요청 가능

<br>

## CPU 스케줄링 기법
#### - 프로세스 상태 전이
#### - 자원을 효율적으로 사용하기 위한 정책, 자원을 요청하는 프로세스 순서를 정함

<br>

### 점유 방식 
#### 1. 선점 (Preemptive) : 프로세스 CPU 점유 시 다른 프로세스 점유 가능 (Round-robin, SRT)
#### 2. 비선점 (Non-preemtive) : 프로세스 CPU 점유식 독점 (FCFS, SJF, HRN)

<br>

### 선점 방식
#### 1. Round-robin (RR) 
* 각 프로세스는 같은 시간동안 CPU를 할당 받음
* 시간이 다 되면 대기 큐로 돌아가고 다음 프로세스에게 CPU 할당

#### 2. SRT (Shortest Remaining Time)
* 수행 시간이 짧은 작업부터 실행하되, 실행 중 다른 프로세스가 더 짧은 시간일 경우 CPU를 점유할 수 있음

### 비선점 방식
#### 1. FCFS (First Come First Service)
* 대기 큐에 도착한 순서대로 CPU를 할당

#### 2. SJF (Short Job First)
* 수행 시간이 짧은 작업부터 CPU 할당
  
#### 3. HRN (Highest Ratio Next)
*SJF를 개선하여, 우선순위가 높은 프로세스에게 CPU 할당

<br>

### Multi Level Queue
* 비선점 방식, 선점 방식 둘 다 가능
* 여러종류의 그룹(큐)로 나누어 각자 독자적인 스케줄링 기법 사용
  
### Mulit Level Feedback Queue
* 그룹(큐)들을 라운드 로빈이나 비선점 방식을 통해 스케줄링 (Hybrid 스케줄링)

<br>

## 병행성 제어
### 상호 배제 (Mutual Exclusion Techniques)
* 다수의 프로세스 동일 자원 접근 시 무결성 보장, 임계영역 사용

#### 1. 임계 영역 (Critical Section)
* 공유 자원의 독점을 보장하는 코드 영역
* 병렬 컴퓨팅 및 동기화 문제 해결에 사용
* 세마포어 개념 이용
* 세마포어 : 공유 자원의 개수를 나타내는 변수, 프로세스 간 동기화를 위해 사용

#### 2. 모니터 상호배제 기법
* 하나의 프로세스만이 모니터 내부에 존재해야함
* 모니터 내부의 지역변수로 정의
* 모니터의 지역변수는 외부에서 접근할 수 없음.

<br>

### 교착 상태 (Dead Lock)
* 하나 이상의 프로세스가 더 이상 계속할 수 없는 특정 사건을 기다리고 있는 상태

<br>

### 교착 상태 발생 조건
#### 1. 상호배제 
* 하나 이상의 프로세스가 자원을 배타 점유
#### 2. 점유와 대기
* 부분할당으로 다른 종류의 자원을 요구하면서 자원 점유
#### 3. 비선점 
* 자원이 해제 되지 않음
#### 4. 환형대기
* 프로세스와 자원들이 원형을 이루며 서로 상대방의 자원을 요청

<br>

### 교착 상태 대응 방법

#### 1. 예방 (Prevention) : 필요 조건을 부정, 교착상태 예방 
* 점유와 대기 부정 : 필요한 자원을 일시에 요청
* 비선점 조건의 부정 : 자원점유 후 자원 요청시 자원해제 선 요청
* 환형대기 조건 부정 : 프로세스들의 자원별로 우선순의 결정
* 상호배제 조건 부정 : 자원 비공유 전제

#### 2. 회피 (Avoidence) : 가능성을 인정, 회피
* 은행원 알고리즘 (안정상태, 불안정상태) : 프로세스가 요구한 최대 요구량 만큼 자원을 할당 (안전순서서열 존재, 교착 상태는 불안전상태에서만 일어남)

#### 3. 발견 (Detection) : 교착상태 발생 허용, 원인을 규명하고 해결
* 교착상태 발견 알고리즘 : 교착상태 발생 검사 알고리즘, 교착상태 빈도수 파악
* 자원할당 그래프 : 방향그래프를 이용, 그래프 소거법을 이용하여 교착상태 감지

#### 4. 회복 (Recovery)
* 프로세스 중지 : 교착 상태를 유발한 프로세스를 종료
* 선점 : 자원을 강제로 회수하여 재분배배

<br>

## 장치관리기법
## 디스크
### 디스크 접근 시간
#### 1. 탐색 시간 : 현위치에서 특정실린더로 디스크 헤드가 이동하는 데 소용되는 시간
#### 2. 회전 지연시간 : 섹터가 디스크 헤드까지 도달하는 시간
#### 3. 전송시간 : 데이터 전송 시간

<br>

### 디스크 스케줄링 기법
#### 1. FCFS (First Come First Served)
* 먼저 들어온 요청 우선 처리
#### 2. SSTF (Shortest-Seek-Time First)
* 탐색거리가 가장 짧은 트랙 요청 우선 처리
#### 3. SCAN (엘레베이터 알고리즘)
* Head가 이동하는 모든 요청을 서비스 끝까지 처리 후 역뱡향 처리
#### 4. C-SCAN
* SCAN에서 바깥쪽에서 안쪽으로 이동
#### 5. C-LOOK
* 진행방향에서 요청없을시 헤드를 처음위치로 이동

<br>

## 파일 시스템
### FAT (File Allocation Table)
#### 1. FAT16 
* 대부분 MS 호환 가능, 2GB, 암호화 및 압축 불가능
* 파일명 최대 영문 8자, 클러스터 1632KB

#### 2. FAT32
* 2TB, 암호화 및 압축 불가능, 파일명 최대 영문 256자, 클러스터 4KB

#### 3. NTFS (New Technology File System)
* 암호화 및 압축 지원
* 가변 클러스터

<br>

### EXT (Extended File System)
#### 1. EXT
* MINIX File System 보완
* 최대 2GB, 파일명 255bytes
* 단편화 문제

#### 2. EXT2
* 2GB, 볼륨 32TB, 오류 수정 지원

#### 3. EXT3 
* 저널링 기능, 온라인 파일 시스템 증대, 디스크조각화 최소화

#### 4. EXT4
* 16GB, 볼륨 16Exabyte, 온라인 조각모음
* 저널 체크섬, 하위호환 가능

<br>

### UFS (Unix File System)
* 유닉스 파일 시스템 (부트블록, 슈퍼블록, 실런더그룹, i-node 테이블)

#### 1. 슈퍼블록 
* 파일 시스템 크기
* i-node 테이블 크기

#### 2. i-node 테이블
* 파일 정보- 파일 크기, 위치
* 유형 허가권, 날짜

<br>

## RAID
* 디스크 고장 시 복구를 위해 2개이상의 디스크에 데이터를 저장하는 기술
* 저 가용성 디스크를 배열 구조로 중복 구성

#### 1. RAID 0
* 최소 2개 디스크
* 데이터를 나누어 저장
* 장애 발생 시 복구 불가

#### 2. RAID 1
* 디스크 완전 이중화
* 많은 비용 발생
* ReadWrite 병렬 가능

#### 3. RAID 2
* Hamming Code를 이용하여 오류 복구

#### 4. RAID 3
* Parity 정보를 별도 디스크에 저장

#### 5. RAID 4
* Parity 정보를 별도 디스크에 블록별 저장
* Write 성능 저하

#### 6. RAID 5
* 분산 Parity 구현
* 안전성 향상

#### 7. RAID 6
* Parity 다중화
* 장애 발생 상황에서도 다른 정상 동작

<br>

## 리눅스 서버 보안

### 리눅스 핵심 구성 요소

#### 1. 쉘 
* 명령어 해석기
* 명령의 입출력 수행 (Bash, Bourne, C, korn)
* 프로그램 실행

#### 2. 커널
* 주기억장치에 상주
* 사용자 프로그램 관리

#### 3. 파일 시스템 
* 정보를 저장하는 기본적 구조
* 계층(트리)구조

<br>

### 리눅스 파일 종류

#### 1. 루트 파일 시스템
* 시스템 프로그램
* 디렉터리

#### 2. 일반 파일
* 프로그램
* 원시 프로그램 파일
* 텍스트 등

#### 3. 디렉터리 파일
* 디렉터리에 관한 정보를 저장하는 논리적인 단위

#### 4. 특수 파일
* 주변장치에 연결된 파일

<br>

## 리눅스 부팅 순서
#### Run Level 0 : PROM 감시
#### Run Level 1 : 사용자 로그인 불가능한 상태, 암호변경할 때 사용
#### Run Level 2 : 공유된 자원이 없는 다중 사용자 단계
#### Run Level 3 : 공유 자원을 가진 다중 사용자 단계
#### Run Level 4 : 사용 되지 않는 단계
#### Run Level 5 : 3단계 기동 후 X-Windows 실행
#### Run Level 6 : 재부팅 단계 -> 3단계로 재부팅

<br>

## 리눅스 인증과 권한 : /etc/passwd
### passwd 파일 구조
#### Root : x : 0 : 0 : root : /root : /bin bash
#### 사용자계정 : 패스워드(/etc/shadow) : UserID : GroupID : Home Directory : Shell

<br>

## 리눅스 권한 관리
#### 1. Umask (r = 4, w = 2, x = 1, User : Group : Other)
* Defalut 권한
* 파일 666 (읽기 + 쓰기, 실행 권한 X)
* 디렉터리 777 (읽기 + 쓰기 + 실행)

| 권한 문자열 | 권한 값 | 의미                       |
|-------------|---------|----------------------------|
| rwx         | 7       | 읽기, 쓰기, 실행 모두 가능 |
| rw-         | 6       | 읽기, 쓰기 가능, 실행 불가 |
| r--         | 4       | 읽기만 가능               |
| -w-         | 2       | 쓰기만 가능               |
| --x         | 1       | 실행만 가능               |
| ---         | 0       | 아무 권한 없음            |

#### 2. chmod
* 권한 부여 명령 (chmod 777 파일명, chmod u+g, g-w, o+r 파일명)
* u = user, g = group, o = other
* chmod u+g 파일명 : 사용자 권한에 그룹 권한 추가
* chmod g-w 파일명 : 그룹의 쓰기 권한 제거
* chmod o+r 파일명 : other의 읽기 권한 추가 

#### 3. chown
* 파일에 대한 사용자 및 그룹 변경
* 소유자 변경 : chown 소유자 파일명
* 그룹 변경 : chown : 그룹 파일명
* 소유자와 그룹 동시에 변경 : chown 소유자 : 그룹 파일명

<br>

## 특수 권한 관리
#### 1. setuid (Set User Id)
* 실행하는 사용자 권한이 아닌 파일 소유자 권한으로 실행 가능 (4000, u+s)
* chmod u+s 파일명
* ls -l에서 권한 표시 : rws로 나타남 (rwsr-xs-x)

#### 2. setgid (Set Group Id)
* 실행하는 사용자의 그룹이 아닌 파일 소유 그룹 권한으로 실행 가능 (2000, g+s)
* chmod g+s 파일명
* ls -l에서 권한 표시 : r-s로 나타남 (rw-r-sr--)

#### 3. stickybit 
* 디렉터리 내에서 파일을 삭제하거나 이름을 변경할 수 있는 권한을 제한 (1000)
* 파일 소유자와 디렉터리 소유자만 디렉터리 내 파일을 삭제, 수정 가능
* 공용 디렉터리 (/tmp)에서 사용됨
* /tmp : 모든 사용자가 접근할 수 있지만, 다른 사용자의 파일을 삭제하지 못하도록 설정
* chmod +t 디렉터리명
* ls -l에서 권한 표시 : t로 나타남 (rwxrwxrwt)

<br>

## 로그파일 (/var/log)
#### 1. 현재 사용자 확인 : w, who - 로그인 사용자 ID, 사용 터미널, 로그인 시간
#### 2. 로그인한 사용자 정보 : /var/utmp
#### 3. 로그인, 로그아웃 정보 : /var/wtmp (last 명령어 사용)
#### 4. 로그인 실패 정보 : /var/btmp

<br>

### Syslog (syslogd >> /etc/syslogd.conf 로그수준)
* 로그 수준을 읽고, 로그를 기록
* 유형 : emerg > alert > erit > err > warn > notice > info > debug

#### 1. emerg 
* 시스템이 사용 불가능할 정도로 심각한 문제 발생

#### 2. alert 
* 즉각적인 조치를 요하는 상태

#### 3. crit (critical) 
* 종요한 오류, 하지만 즉시 처리하지않으면 심각한 문제가 발생할 가능성이 있는 상태
  
#### 4. err (Error)
* 일반적인 오류
  
#### 5. warn (Warning)
* 경고, 조치를 취하지 않으면 문제가 될 수 있음
  
#### 6. notice
* 일반적인 정보 메시지
* 시스템 상태나 변경 사항을 알려주는 메시지
 
#### 7. info (Informational)
* 시스템이 정상적으로 작동하고 있다는 메시지

#### 8. debug (Debugging)
* 주로 개발자나 시스템 관리자가 문제를 해결하기 위해 사용되는 상세한 로그 정보









































































































